#if 0
float data[] = {1, 2, 3, 4, 5, 6, 7, 8};
__m256 data256 = _mm256_load_ps(data);
struct puned { float d1,d2,d3,d4,d5,d6,d7,d8; } data256pun = *((struct puned*)&data256);
struct puned copy = {
	data256pun.d7,data256pun.d6,data256pun.d3,data256pun.d2,
	data256pun.d5,data256pun.d4,data256pun.d1,data256pun.d0
};
data256 = *((__m256*)&copy);
/* done? */
#endif
static inline __m256 _mm256_complex_multiply(__m256 a, __m256 b)
{
	print_complex_array((complex_t*)&a, 4, "complex mult: a");
	print_complex_array((complex_t*)&b, 4, "complex mult: b");
	__m256 ab_real = _mm256_mul_ps(a, b);
	__m256 ab_imag = _mm256_mul_ps(a, _mm256_permute_ps(b, _MM_SHUFFLE(2,3,0,1)));
	ab_real = _mm256_hsub_ps(ab_real, ab_real);
	print_complex_array((complex_t*)&ab_real, 4, "complex mult: ar*br - ai*bi");
	ab_imag = _mm256_hadd_ps(ab_imag, ab_imag);
	__m256 result = _mm256_shuffle_ps(ab_real, ab_imag, _MM_SHUFFLE(3,2,1,0));
	return result;
}

static inline __m256 _mm256_fft_kernel_4(__m256 x)
{
	_mem_align(16) static const float twd4[4] = {0.f, -0.f, 0.f, 0.f};
	__m128 conjugator = *(__m128*)twd4;
	// Final result
	__m256 result = _mm256_setzero_ps(); 
	// First step is to permute the vector
	__m128 lo = _mm256_extractf128_ps(x, 0);
	__m128 hi = _mm256_extractf128_ps(x, 1);
	
	__m128 temp = _mm_shuffle_ps(lo, hi, _MM_SHUFFLE(1,0,1,0));
	hi = _mm_shuffle_ps(lo, hi, _MM_SHUFFLE(3,2,3,2));
	lo = temp;
	
	result = _mm256_insertf128_ps(result, lo, 0);
	result = _mm256_insertf128_ps(result, hi, 1);
	
	// Perform the butterflies for first stage
	result = _mm256_fft_two_butterflies(result);

	// Now at second stage	
	// Multiplying by the twiddle factor (-j)
	lo = _mm256_extractf128_ps(result, 0);
	hi = _mm256_extractf128_ps(result, 1);

	hi = _mm_xor_ps(_mm_permute_ps(hi, _MM_SHUFFLE(2,3,1,0)), conjugator);

	temp = _mm_shuffle_ps(lo, hi, _MM_SHUFFLE(1,0,1,0));
	hi = _mm_shuffle_ps(lo, hi, _MM_SHUFFLE(3,2,3,2));
	lo = temp;
	
	// Insert back into large vector
	result = _mm256_insertf128_ps(result, lo, 0);
	result = _mm256_insertf128_ps(result, hi, 1);

	// Do the butterfly for 2nd stage
	result = _mm256_fft_two_butterflies(result);
	
	lo = _mm256_extractf128_ps(result, 0);
	hi = _mm256_extractf128_ps(result, 1);
	temp = _mm_shuffle_ps(lo, hi, _MM_SHUFFLE(0,1,1,0));
	hi = _mm_shuffle_ps(lo, hi, _MM_SHUFFLE(2,3,2,3));
	lo = temp;
	
	// Insert back into large vector
	result = _mm256_insertf128_ps(result, lo, 0);
	result = _mm256_insertf128_ps(result, hi, 1);
	
	// DONE!
	return result;
}

void debug_sse(__m128 v, const char* msg){
	printf("+------------------------------------------------+\n");
	printf("%c%c%c |", msg[0],msg[1],msg[2]);
	typedef union {
		__m128 V;
		float  f[4];
	} weirdtype;
	weirdtype temp;
	temp.V = v;
	float *x = temp.f;
	unsigned char i;
	for(i = 4; i--; ){
		printf("  %5.2e", x[i]);
	}
	printf("  |\n");
	printf("+------------------------------------------------+\n");
}
void debug_avx(__m256 v, const char* msg){
	printf("+------------------------------------------------+\n");
	printf("%c%c%c |", msg[0],msg[1],msg[2]);
	typedef union {
		__m256 V;
		float  f[8];
	} weirdtype;
	weirdtype temp;
	temp.V = v;
	float *x = temp.f;
	unsigned char i;
	for(i = 8; i--; ){
		if(i == 3) printf("\n");
		printf("  %5.2e", x[i]);
	}
	printf("  |\n");
	
	printf("+------------------------------------------------+\n");
}

void benchmark_fft_kernel_4(void){
	size_t iteration = 1000000, n = iteration;
	_mem_align(32) complex_t in[4];
	__m256* input = (__m256*)in;
	double tav = 0.0, t0, t1;
	while(n--){
		for(int i = 4; i--; ) { 
			in[i][0] = rand_float(0.f, 1.f); 
			in[i][1] = rand_float(0.f, 1.f); 
		}
		t0 = get_time();
		*input = _mm256_fft_kernel_4(*input);
		t1 = get_time();
		tav += (t1 - t0);
	}
	tav /= (double)iteration;
	printf("4 point dft took %es\n", tav);
}
int main2 (void)
{
	#ifdef _FFT_VECTOR_SUPPORT_ENABLED_
	printf("FFT using AVX\n");
	#else
	printf("FFT Using Scaler\n");
	#endif
	
	FFT_BITREVERSER revbin = fft_bitreverse_select(3);
	for(size_t i = 0; i < 8; i++){
		printf("%lu --> %lu\n", i,revbin(i,3));
	}
	printf("_MM_SHUFFLE(3,1,2,0) = %d\n", _MM_SHUFFLE(3,1,2,0));
	vector_4_ps x;
	x.element[0] = 2.f;	x.element[1] = 1.f;
	x.element[2] = 3.f; x.element[3] = 4.f;
	printf("Testing two point fft\n");
	print_complex_array((complex_t*)x.element, 2, "in");
	x.vector = _mm_fft_butterfly(x.vector);
	print_complex_array((complex_t*)x.element, 2, "out");;
	
	printf("Testing double two point fft\n");
	vector_8_ps xd;
	xd.element[0] = 2.f;	xd.element[1] = 1.f;
	xd.element[2] = 3.f; 	xd.element[3] = 4.f;
	xd.element[4] = 2.f;	xd.element[5] = 1.f;
	xd.element[6] = 3.f; 	xd.element[7] = 4.f;
	print_complex_array((complex_t*)xd.element, 4, "in");
	xd.vector = _mm256_fft_two_butterflies(xd.vector);
	print_complex_array((complex_t*)xd.element, 4, "out");
	
	return 0;
}
int main3 (void)
{
	printf("Testing complex multiplication\n");
	_mem_align(32) complex_t a[4] = {{1,2},{3,4},{5,6},{7,8}};
	_mem_align(32) complex_t b[4] = {{1,2},{4,3},{5,6},{7,8}};
	_mem_align(32) complex_t R[4];
	print_complex_array(a, 4, "a");
	print_complex_array(b, 4, "b");
	*(__m256*)R = _mm256_complex_mult_ps(*(__m256*)a, *(__m256*)b);
	print_complex_array(R, 4, "a * b");
	return 0;
}